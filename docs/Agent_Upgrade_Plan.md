# Agent 架构升级规划：引入通用工具调用能力

## 1. 愿景 (Vision)

将当前项目从一个专注于信息检索的 **RAG Agent**，演进为一个能够理解复杂指令、自主选择并使用多种工具（包括但不限于RAG）来完成任务的**通用工具调用Agent (Tool-Calling Agent)**。

- **当前架构**：一个“智能路由器”，根据预设逻辑和问题类型，在不同的**检索策略**之间进行选择。
- **未来架构**：一个“智能思考者”，拥有一个包含多种**工具**的“工具箱”，能根据任务目标，自主规划并执行“思考 -> 行动 -> 观察”的循环，直至问题解决。

## 2. 核心思想：从“路由器”到“思考者”

本次升级的核心，是用一个通用的 **`AgentExecutor` (代理执行器)** 来替换掉当前自定义的、较为固定的 `LangGraph` 工作流。`AgentExecutor` 基于 **Tool Calling** 或 **ReAct** 等先进思想，其工作模式如下：

1.  **思考 (Think)**：LLM（大脑）分析用户问题和历史记录，决定下一步是直接回答，还是需要使用工具。
2.  **行动 (Act)**：如果决定使用工具，LLM会输出一个结构化的指令（如JSON），指明要调用的**工具名称**和所需的**参数**。
3.  **观察 (Observe)**：`AgentExecutor` 捕获这个指令，执行对应的工具，并将工具返回的结果（无论是数据库查询结果、代码执行输出，还是文档片段）作为“观察”结果。
4.  **再次思考**：`AgentExecutor` 将“观察”结果连同历史记录一起再次提交给LLM，让它在新的信息基础上决定下一步行动（是调用另一个工具，还是已经可以总结出最终答案）。

这个循环会一直持续，直到LLM认为任务已完成并给出最终答案为止。

## 3. 实施蓝图 (Implementation Blueprint)

### 第一阶段：构建并封装新工具

在改造Agent的大脑之前，先为它打造一个强大的“工具箱”。建议在 `agentic_rag` 目录下创建一个新的 `tools` 子目录来统一管理所有工具。

#### 1.1. 结构化数据查询工具 (SQL Tool)

- **目标**：让Agent能查询关系型数据库。
- **实施**：
    1.  创建一个示例数据库（如 `sample_db.sqlite`），包含`products`等表。
    2.  在 `agentic_rag/tools/sql_tool.py` 中，利用 LangChain 的 `SQLDatabaseToolkit` 来创建一套完整的SQL工具。该工具包能自动处理数据库连接、Schema检查、SQL语句生成与安全执行。

#### 1.2. 代码执行工具 (Code Interpreter Tool)

- **目标**：让Agent能执行Python代码以完成计算、数据分析等任务。
- **实施**：
    1.  在 `agentic_rag/tools/code_interpreter_tool.py` 中，封装 LangChain 提供的 `PythonREPLTool`。
    2.  **（重要）安全警告**：必须明确此工具的风险。在生产环境中，代码执行需要被严格限制在沙箱环境（如Docker容器）内。初期可使用REPL作为功能验证。

#### 1.3. 现有能力工具化

- **目标**：将我们已经实现的各种检索能力，也包装成标准化的“工具”。
- **实施**：
    1.  **分层检索** -> 包装成 `hierarchical_search_tool`，并配上清晰的描述：“当需要回答关于文档的开放性、概念性问题时使用。”
    2.  **直接区块检索** -> 包装成 `direct_chunk_search_tool`，描述：“当需要精确查找知识库中的特定实体（如药品名称、产品型号）时使用。”
    3.  **网络搜索** -> 包装成 `web_search_tool`，描述：“当需要获取最新信息或通用知识时使用。”

### 第二阶段：重构 Agent 核心架构

- **目标**：用 `AgentExecutor` 替换现有的 `LangGraph` 逻辑。
- **实施**：
    1.  **创建统一的工具箱**：将第一阶段创建的所有工具（SQL, Code, RAG, Web）收集到一个列表中。
    2.  **构建Agent大脑**：使用 LangChain 的 `create_openai_tools_agent` 等构造函数，将一个支持Tool Calling的LLM、一个为工具使用而设计的Prompt模板、以及上述工具列表绑定，创建一个Agent。
    3.  **引入Agent执行器**：将创建的Agent包装进一个 `AgentExecutor` 中。

### 第三阶段：简化并重建工作流图 (`graph.py`)

- **目标**：用一个极简的、以Agent为核心的图来取代当前复杂的条件分支图。
- **实施**：
    1.  **新的图结构**：新的`LangGraph`将只有一个核心节点 `agent_node` 和一个条件分支。
    2.  **工作流程**：
        - 所有请求都进入 `agent_node`，该节点调用 `AgentExecutor`。
        - `AgentExecutor` 执行其内部的“思考->行动”循环。
        - `agent_node` 执行完毕后，进入条件分支，判断 `AgentExecutor` 的输出是中间步骤（工具结果）还是最终答案。
        - 如果是中间步骤，则循环回到 `agent_node`；如果是最终答案，则流程结束。

**新图景**:
```
           +-------------------------------------------------+
           |                                                 |
(Start) -->|  agent_node (调用 AgentExecutor, 内部循环)   |<--+ (Loop)
           |                                                 |
           +-----------------------+-------------------------+
                                   |
                                   | (Is final answer?)
                                   v
                                 (End)
```

## 4. 实施建议

本次架构升级影响较大，建议分步实施：

1.  **先实施第一阶段**：专注于创建和封装各种工具，特别是SQL和代码执行工具。确保每个工具都能独立、稳定地工作。
2.  **再实施第二和第三阶段**：在工具齐备后，再进行核心Agent的替换和新Graph的构建工作。

这份文档为您未来的开发提供了一个清晰的路线图。当您准备好启动这个计划时，我们可以从第一阶段开始着手。
